# -*- coding: utf-8 -*-
"""
МОДУЛЬ Г: Сетевой анализ и рекомендации
ПРОСТАЯ РАБОЧАЯ ВЕРСИЯ
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from sqlalchemy import create_engine, text

# ==========================================================
# 1. ПОДКЛЮЧЕНИЕ К БД
# ==========================================================
TEAM_ID = "1"  # ВАЖНО: замените на ваш номер команды!

# Подключение к PostgreSQL
engine = create_engine('postgresql://user:password@localhost:5432/dbname')

# Проверка подключения
try:
    with engine.connect() as conn:
        conn.execute(text("SELECT 1"))
    print("✓ Подключение к БД успешно")
    LOCAL_MODE = False
except Exception as e:
    print(f"✗ Ошибка подключения: {e}")
    print("Работаем в локальном режиме")
    LOCAL_MODE = True

# ==========================================================
# 2. ПОЛУЧЕНИЕ ДАННЫХ ДЛЯ ГРАФА
# ==========================================================
print("\n" + "="*50)
print("ПОЛУЧЕНИЕ ДАННЫХ ДЛЯ ГРАФА")
print("="*50)

# Пытаемся найти данные в БД
data = None

if not LOCAL_MODE:
    # Пробуем разные варианты
    queries = [
        """
        SELECT customer_id, product_id, COUNT(*) as weight
        FROM orders 
        GROUP BY customer_id, product_id 
        LIMIT 1000
        """,
        """
        SELECT product1_id, product2_id, COUNT(*) as weight
        FROM product_pairs 
        GROUP BY product1_id, product2_id 
        LIMIT 1000
        """,
        """
        SELECT supplier_id, warehouse_id, COUNT(*) as weight
        FROM deliveries 
        GROUP BY supplier_id, warehouse_id 
        LIMIT 1000
        """
    ]
    
    for query in queries:
        try:
            data = pd.read_sql(query, engine)
            if len(data) > 0:
                print(f"✓ Данные загружены: {len(data)} строк")
                break
        except:
            continue

# Если данных нет - создаем тестовые
if data is None or len(data) == 0:
    print("! Создаем тестовые данные")
    np.random.seed(42)
    
    # Генерируем связи
    n_nodes1 = 20  # например, клиенты
    n_nodes2 = 15  # например, товары
    
    edges = []
    for i in range(1, n_nodes1 + 1):
        n_connections = np.random.randint(1, 6)
        for j in np.random.choice(range(1, n_nodes2 + 1), n_connections, replace=False):
            weight = np.random.randint(1, 5)
            edges.append({
                'source': f'N1_{i}',
                'target': f'N2_{j}',
                'weight': weight
            })
    
    data = pd.DataFrame(edges)
    print(f"✓ Создано {len(data)} связей")

print(f"\nДанные:")
print(data.head())

# ==========================================================
# 3. ПОСТРОЕНИЕ ГРАФА
# ==========================================================
print("\n" + "="*50)
print("ПОСТРОЕНИЕ ГРАФА")
print("="*50)

# Создаем граф
G = nx.Graph()

# Добавляем ребра
for _, row in data.iterrows():
    if len(row) >= 3:
        G.add_edge(row[0], row[1], weight=row[2])
    else:
        G.add_edge(row[0], row[1], weight=1)

print(f"Граф создан:")
print(f"  Узлов: {G.number_of_nodes()}")
print(f"  Ребер: {G.number_of_edges()}")

# ==========================================================
# 4. РАСЧЕТ МЕТРИК
# ==========================================================
print("\n" + "="*50)
print("РАСЧЕТ МЕТРИК")
print("="*50)

# Степени узлов
degrees = dict(G.degree())
degree_values = list(degrees.values())

print(f"Степени узлов:")
print(f"  Средняя: {np.mean(degree_values):.2f}")
print(f"  Макс: {max(degree_values)}")
print(f"  Мин: {min(degree_values)}")

# Плотность
density = nx.density(G)
print(f"\nПлотность графа: {density:.4f}")

# Компоненты связности
components = list(nx.connected_components(G))
print(f"Компонент связности: {len(components)}")

if len(components) > 0:
    largest = max(components, key=len)
    print(f"Самая большая компонента: {len(largest)} узлов")

# Топ узлов по степени
top_nodes = sorted(degrees.items(), key=lambda x: x[1], reverse=True)[:10]
print("\nТоп-10 узлов по степени:")
for node, deg in top_nodes[:5]:
    print(f"  {node}: {deg}")

# Сохраняем метрики
metrics_df = pd.DataFrame([
    {'metric': 'nodes', 'value': G.number_of_nodes()},
    {'metric': 'edges', 'value': G.number_of_edges()},
    {'metric': 'avg_degree', 'value': np.mean(degree_values)},
    {'metric': 'max_degree', 'value': max(degree_values)},
    {'metric': 'density', 'value': density},
])

if not LOCAL_MODE:
    metrics_df.to_sql(f"team_{TEAM_ID}_graph_metrics", engine, if_exists='replace', index=False)

# ==========================================================
# 5. ВИЗУАЛИЗАЦИЯ ГРАФА
# ==========================================================
print("\n" + "="*50)
print("ВИЗУАЛИЗАЦИЯ ГРАФА")
print("="*50)

plt.figure(figsize=(12, 8))

# Расположение узлов
pos = nx.spring_layout(G, k=2, iterations=50)

# Размер узлов по степени
node_sizes = [300 + degrees[n] * 100 for n in G.nodes()]

# Цвета для разных типов узлов
node_colors = []
for node in G.nodes():
    if 'C_' in str(node) or 'customer' in str(node) or 'N1_' in str(node):
        node_colors.append('skyblue')
    elif 'P_' in str(node) or 'product' in str(node) or 'N2_' in str(node):
        node_colors.append('lightgreen')
    else:
        node_colors.append('lightgray')

# Рисуем граф
nx.draw_networkx_nodes(G, pos, node_size=node_sizes, node_color=node_colors, alpha=0.8)
nx.draw_networkx_edges(G, pos, alpha=0.3, width=1)
nx.draw_networkx_labels(G, pos, font_size=8)

plt.title("Граф связей")
plt.axis('off')
plt.tight_layout()
plt.savefig('graph.png', dpi=150, bbox_inches='tight')
print("✓ graph.png сохранен")

# Дополнительный график - распределение степеней
plt.figure(figsize=(10, 5))
plt.hist(degree_values, bins=20, edgecolor='black')
plt.title('Распределение степеней узлов')
plt.xlabel('Степень')
plt.ylabel('Количество узлов')
plt.grid(True, alpha=0.3)
plt.savefig('degree_distribution.png')
print("✓ degree_distribution.png сохранен")

# ==========================================================
# 6. РЕКОМЕНДАЦИИ
# ==========================================================
print("\n" + "="*50)
print("ФОРМИРОВАНИЕ РЕКОМЕНДАЦИЙ")
print("="*50)

# Определяем тип графа для рекомендаций
if any('C_' in str(n) for n in G.nodes()) and any('P_' in str(n) for n in G.nodes()):
    graph_type = "клиент-товар"
elif any('P1' in str(n) for n in G.nodes()):
    graph_type = "товар-товар"
else:
    graph_type = "общий"

print(f"Тип графа: {graph_type}")

recommendations = []

if graph_type == "клиент-товар":
    # Рекомендации товаров: что с чем покупают
    products = [n for n in G.nodes() if 'P_' in str(n) or 'N2_' in str(n)]
    
    # Для популярных товаров
    popular = sorted([(n, G.degree(n)) for n in products], key=lambda x: x[1], reverse=True)[:5]
    recommendations.append("Популярные товары:")
    for prod, deg in popular:
        recommendations.append(f"  - {prod}: {deg} покупателей")
    
    # Перекрестные продажи (если есть связи между товарами)
    # В двудольном графе их нет, поэтому просто советуем
    
elif graph_type == "товар-товар":
    # Находим пары товаров с большим весом
    edges_with_weight = [(u, v, d['weight']) for u, v, d in G.edges(data=True)]
    top_pairs = sorted(edges_with_weight, key=lambda x: x[2], reverse=True)[:5]
    
    recommendations.append("Рекомендуемые пары товаров:")
    for u, v, w in top_pairs:
        recommendations.append(f"  - {u} и {v}: {w} совместных покупок")

# Общие рекомендации
recommendations.append("\nБизнес-рекомендации:")
recommendations.append("  1. Сфокусироваться на узлах с высокой степенью - это ключевые элементы")
recommendations.append("  2. Для слабосвязанных узлов - усилить связи")
recommendations.append("  3. Использовать популярные комбинации в маркетинге")

print("\n".join(recommendations))

# ==========================================================
# 7. ОТЧЕТ
# ==========================================================
print("\n" + "="*50)
print("ОТЧЕТ")
print("="*50)

report = f"""
========================================
ОТЧЕТ ПО СЕТЕВОМУ АНАЛИЗУ
Команда: {TEAM_ID}
========================================

1. ХАРАКТЕРИСТИКИ ГРАФА
   Узлов: {G.number_of_nodes()}
   Ребер: {G.number_of_edges()}
   Плотность: {density:.4f}
   Средняя степень: {np.mean(degree_values):.2f}
   Макс. степень: {max(degree_values)}

2. КЛЮЧЕВЫЕ УЗЛЫ
"""
for node, deg in top_nodes[:5]:
    report += f"   - {node}: степень {deg}\n"

report += f"""
3. РЕКОМЕНДАЦИИ
"""
for rec in recommendations:
    report += f"   {rec}\n"

report += f"""
========================================
"""

print(report)

with open(f'team_{TEAM_ID}_graph_report.txt', 'w', encoding='utf-8') as f:
    f.write(report)

# Сохраняем данные для репозитория
edges_df = pd.DataFrame(list(G.edges(data=True)), columns=['source', 'target', 'data'])
edges_df.to_csv(f'team_{TEAM_ID}_edges.csv', index=False)

nodes_df = pd.DataFrame(list(G.nodes()), columns=['node'])
nodes_df.to_csv(f'team_{TEAM_ID}_nodes.csv', index=False)

print("✓ Отчет сохранен")
print("✓ edges.csv сохранен")
print("✓ nodes.csv сохранен")
print("\n✅ МОДУЛЬ Г ВЫПОЛНЕН!")
